
 1) Creational

*Abstract factory*  abstract class DocumentCreator with interfaces createDocument() etc. -> concrete versions ModernDocumentCreator, QuickDocumentCreator etc.
*Builder* interface Builder, implementation Concretebuilder -> creates Product from class. Director class refers to Builder to build Product
*Factory method* rather than calling constructor, call Factory method to create object : Room makeRoom() { return new Room()}
*Prototype* clone prototype instance to create new object : 
    Properties only : let clone = {...customer} OR let clone = Object.assign({},customer)
    Properties, methods , shallow copy : let clone = Object.create(customer)
    Deep copy: let clone = JSON.parse(JSON.stringify(customer))
*Singleton* only one instance ,  private static _instance:Class , public static get Instance() {return this._instance || (this._instance = new this());}

2) Structural

*Adapter* convert interface into an another interface: Client {adaptor:Adaptor  adaptor.methodA(); }; Adaptor {adaptee:Adaptee  methodA(){adeptee.MethodB();} }; Adaptee {methodB();}
*Bridge* decouple abstract class from implementation: AbstractAccount {protected operate() {logger.log()} } Account extends AbstractAccount {withdraw(){ balance--;operate()}}
*Composite* CompositeGraphic { List childs; add(Graphic graphic){childs.add(graphic)}; } CG=new CompositeGraphic();  CG.add(new Circle()); CG.add(new Circle());
*Decorator* Add behavior to object dynamically without affecting other objects of same class. Abstract class CoffeeDecorator implements Coffee { private final Coffee decoratedCoffee; }
*Facade* Object that serves as front facing interface for complex code.  Abstraction layer between core and presentation layers
*Flyweight* Minimize memory use by sharing data with other objects. FontCharacter { Glyph = getSharedGlyph(Character x);}
*Proxy* 
